#+TITLE: مدار منطقی

# جدول کارنو

# گری حلزونی
# همینگ
# توازن زوج و فرد parity
# مدل زود صفرها را زوج میکنه اگه یک بود یه یک دیگه هم اضافه میکنه که زوج شه
# اکس‌ار وقتی یکه که تعداد یک‌های ورودی فردن
# d همیشه مینیموم فاصله بین کدهاست

# برای سیستمی که خطای چسبیدگی به صفر در اون رایجه پریتی زوج خوب نیست
# پریتی فرد برای سیستمی که استاک ات یک داره به کار نمیاد
# در تعداد بیت‌های زوج (به جز خود پریتی)
# C1 میشه xor بیت‌هایی که در آنها یک دارند. ۳+۱، ۴+۱، ۶+۱
# C2 میشه xor بیت‌هایی که در آنها دو دارند
# C4 // // // // // /// // // // /// // چهار دارند.

# به ازای n متغیر (2^n)^n تابع بوولی میتوان داشت.

* Preamble :noexport:
:PROPERTIES:
:VISIBILITY: folded
:END:
#+AUTHOR: ​@@latex:\rl{@@​محمدیاسین داوده​@@latex:}@@​

** TeX
#+PROPERTY: header-args:latex :headers '("\\usepackage{circuitikz}") :exports results :results file graphics replace output :imagemagick yes :iminoptions -density 250 :fit yes

*** Persian
#+LANGUAGE: fa
#+LATEX_HEADER: \usepackage{xepersian}\settextfont{XB Roya}\setlatintextfont{XB Roya}\setmonofont{Iosevka}
# #+LATEX_HEADER: \usepackage{shamsi} \project{} \supervisor{}

#+LATEX_HEADER: \xpretocmd{\tabular}{\begin{latin}}{}{} \xapptocmd{\endtabular}{\end{latin}}{}{}
#+LATEX_HEADER: \captionsetup[table]{name=جدول}

#+LATEX_HEADER: \setLTRbibitems

**** Minted
#+LATEX_HEADER: \xpretocmd{\verbatim}{\begin{LTR}}{}{} \xapptocmd{\endverbatim}{\end{LTR}}{}{} \xpretocmd{\minted}{\VerbatimEnvironment\begin{latin}}{}{} \xapptocmd{\endminted}{\end{latin}}{}{}
#+LATEX_HEADER: \LetLtxMacro{\oldmintinline}{\mintinline}\renewcommand{\mintinline}[3][]{\lr{\oldmintinline[#1]{#2}{#3}}}
#+LATEX_HEADER: \SetupFloatingEnvironment{listing}{name=کد}

** Macros
#+MACRO: lr @@latex:\lr{@@​$1​@@latex:}@@
#+MACRO: lt @@latex:\lr{@@​~$1~​@@latex:}@@

** Bibliography
#+LATEX_HEADER: \def\UrlBreaks{\do\/\do-}
[[bibliographystyle:unsrtnat]]


* مبناها، مکمل و کدها
** مبناها
یک عدد، $a$, با $n$ رقم، عدد صحیح و $m$ رقم اعشار را می‌توان به صورت زیر نوشت:

\begin{equation*}
  a = \underbrace{a_{n-1}a_{n-2} \ldots a_2a_1a_0}_{\text{$n$ عدد صحیح}}.\underbrace{a_{-1}a_{-2} \ldots a_{-m}}_{\text{$m$ عدد اعشار}}
\end{equation*}

هر عدد در مبنای $n$ شامل $n$ رقم یکتا از $0$ تا $n$ است.
هنگامی که مبنا از ۱۰ بالاتر می‌رود ارقام بالاتر از ۹ را با حروف الفبای انگلیسی نمایش می‌دهیم ($\{0,1,2,3,4,5,6,7,8,9,A,B,C,D,F\}$).

برای تبدیل عددی از مبنای $r$ به مبنای ده‌دهی ({{{lr(Decimal)}}}) کافیست هر رقم را در
ارزش مکانی خودش ضرب کنیم و حاصل را با هم جمع کنیم:

\begin{equation}\begin{split}
  a = a_{n-1} \times r^{n-1} + \ldots + a_{0} \times r^{0} + a_{-1} \times r^{-1} + \ldots + a_{-m} \times r^{-m}\\
  = \sum_{i=-m}^{n-1}a_{i}r^{i}
\end{split}\end{equation}

بزرگترین عدد صحیح $n$ رقمی در مبنای $r$ همواره برابر با $(r-1)(r-1)\ldots(r-1)$ است.
به طور مثال در مبنای ده‌دهی $999\ldots999$ و در مبنای شانزدهی $FFF\ldots{}FFF$ بزرگترین عدد صحیح است.
مقدار این عدد به صورت زیر به دست می‌آید:

\begin{equation} \label{eq:max_num}
  \sum_{i=0}^{n-1}(r-1)r^{i} = (r-1)\sum_{i=0}^{n-1}r^{i} \overset{\text{تصاعد هندسی}}{=} (r-1)(\frac{r^{n}-1}{r-1}) = r^{n} -1
\end{equation}

بیشترین مقدار صحیحی که $n$ رقم مبنای $r$ می‌توانند نمایش دهند $r^{n} - 1$ است.
بزرگترین عدد اعشاری $n$ رقمی مبنای $r$ با $m$ رقم اعشار می‌تواند نمایش دهند $r^{n} - r^{-m} - 1$ است.

** مکمل‌ها
مکمل $r$ ({{{lr(Radix complement)}}}) و $r-1$ ({{{lr(Reduced complement)}}}) عدد $n$ رقمی $a$ با $m$ عدد اعشار به شکل زیر به دست می‌آید:

\begin{equation}
  [a]_{r} = r^{n} - a = [a]_{r-1} + 1 \label{eq:radix}
\end{equation}
\begin{equation}
  [a]_{r-1} = r^{n} - r^{-m} - a = [a]_{r} - r^{-m}
\end{equation}

مکمل یک دودویی برابر با Not آن است ($[(a)_{2}]_{1} = \bar{a}$).

روش‌های خوانش اعداد دودویی:
- بی‌علامت: عدد به طور عادی خوانده می‌شود ($(101100)_{2} = 44$).
  - بزرگترین مقدار با $n$ رقم: $r^{n}-1$.
  - کوچکترین مقدار: $0$.
- علامت‌دار: اولین رقم از سمت راست علامت عدد است. یک منفی و صفر مثبت است ($(101100)_{2} = -12$).
  - بزرگترین مقدار با $n$ رقم: $r^{n-1}-1$.
  - کوچکترین مقدار: $-(r^{n-1}-1)$.
- مکمل 1 ($r-1$)‌: بزرگترین رقم ارزشی برابر منفی خودش منهای یک یا $-r^{n}-1$ دارد ($(101100)_{2} = -(010011)_{2} = -19$).
  - بزرگترین مقدار با $n$ رقم: $r^{n-1}-1$.
  - کوچکترین مقدار: $-(r^{n-1}-1)$.
- مکمل 2 ($r$)‌: مکمل یک بعلاوه یک (طبق فرمول ref:eq:radix) است. بزرگترین رقم ارزشی برابر با منفی خودش یا $-r^{n}$ دارد ($(101100)_{2} = -(010100)_{2} = -20$).
  - بزرگترین مقدار با $n$ رقم: $r^{n-1}-1$.
  - کوچکترین مقدار: $-r^{n-1}$.
در تمام سیستم‌ها به جز مکمل ۲ به دو روش می‌توان $0$ را نمایش داد.
بجز این سیستم به همین دلیل جای $0^{-}$ می‌توان عددی دیگر هم در سیستم گنجاند می‌توان عددی دیگر هم در سیستم گنجاند.
با تکرار بیت آخر در این سیستم مقدار عدد تغییر نمی‌کند ({{{lr(Sign extension)}}}).

** تبدیل
برای تبدیل عددی از مبنای $r$ به مبنای $r^{n}$ به ازای هر $n$ رقم در مبنای $r$ باید یک رقم در مبنای $r^{n}$ قرار دهیم.

در جمع عدد‌های مکمل دو تعداد ارقام باید برابر باشد. برای برابر کردن عدد نماد را می‌افزایم ({{{lr(Sign extend)}}} می‌کنیم).

در سیستم مکمل دو از کری (عدد مرتبه بالاتر) آخر جمع صرف نظر می‌کنیم.

هنگامی سرریز پیش می‌آید که رقم نقلی آخر و خارج شده ($c_{n}$) نامساوی با رقم نقلی یکی مانده به آخر و وارد شده ($c_{n-1}$) باشد.
گاهی بدون داشتن رقم‌های نقلی می‌توان سرریز را مشخص کرد.
هنگامی که جمع دو عدد منفی، مثبت می‌شود، یا بالعکس، سرریز رخ داده است.
حاصل جمع هنگامی سرریز می‌کند که جواب دو عدد $n$ رقمی را در $n$ بیت یا کمتر دخیره کنیم.
حاصل جمع دو عدد $n$ رقمی برابر یا $+1$ آنها است.

اگر تفریق را با روش $a + [b]_{2}$ انجام ندهیم فلگ Carry نداریم و جای آن از Borrow استفاده می‌کنیم.

به هنگام تفریق وضعیت‌های زیر با فلگ‌های زیر پیش می‌آید:

\begin{equation}
  a-b\begin{cases}
    Sign = Overflow, a >= b\\
    Sign \neq Overflow, a < b\\
    Zero = 1, a = b
  \end{cases}
\end{equation}

بنابر فرمول ref:eq:max_num $a$ یا بزرگترین عدد $n$ رقمی در مبنای 10 حداقل $k$ بیت در مبنای $r$ احتیاج دارد. چرا که $r^{n}-1 <= a$ باشد.

\begin{equation}
  k = \lfloor \log_{r}a \rfloor + 1
\end{equation}

برای تبدیل قسمت صحیح عدد $(a)_{10}$ به مبنای $r$ از تقسیم متوالی و یادداشت باقیمانده به ترتیب برعکس به دست آمده استفاده می‌کنیم.
برای تبدیل قسمت اعشاری عدد $(a)_{10}$ به مبنای $r$ از ضرب متوالی و یادداشت صورت حاصل استفاده می‌کنیم.


** کدها

#+CAPTION: کدهای Binary Coded Decimals که در آن بیت‌ها به ترتیب مقادیر $1$, $2$, $4$ و $8$ را دارند.
| Decimal | BCD  |
|---------+------|
|   <c>   | <c>  |
|    0    | 0000 |
|    1    | 0001 |
|    2    | 0010 |
|    3    | 0011 |
|    4    | 0100 |
|    5    | 0101 |
|    6    | 0110 |
|    7    | 0111 |
|    8    | 1000 |
|    9    | 1001 |

#+CAPTION: کدهای Excess-3
| Decimal |      Excess-3      |
|---------+--------------------|
|   <c>   |        <c>         |
|    0    |        0011        |
|    1    |        0100        |
|    2    |        0101        |
|    3    |        0110        |
|    4    |        0111        |
|    5    |        1000        |
|    6    |        1001        |
|    7    |        1010        |
|    8    |        1011        |
|    9    |        1100        |


#+CAPTION: کدهای $8 4 \bar{2} \bar{1}$ که در آن بیت‌ها به ترتیب مقادیر $-1$, $-2$, $4$ و $8$ را دارند.
| Decimal | $84\bar{2}\bar{1}$ |
|---------+--------------------|
|   <c>   |        <c>         |
|    0    |        0000        |
|    1    |        0111        |
|    2    |        0110        |
|    3    |        0101        |
|    4    |        0100        |
|    5    |        1011        |
|    6    |        1010        |
|    7    |        1001        |
|    8    |        1000        |
|    9    |        1111        |

#+CAPTION: کدهای $2421$ که در آن بیت‌ها به ترتیب مقادیر $1$, $2$, $4$ و $2$ را دارند.
| Decimal | $2421$ |
|---------+--------|
|   <c>   |  <c>   |
|    0    |  0000  |
|    1    |  0001  |
|    2    |  0010  |
|    3    |  0011  |
|    4    |  0100  |
|    5    |  1011  |
|    6    |  1100  |
|    7    |  1101  |
|    8    |  1110  |
|    9    |  1111  |

کد خود مکمل کدی است که اگر آنرا Not کنید (مکمل $1$ یا $r-1$ آنرا در دودویی بگیریم)، برابر مکمل $9$ یا $r-1$ آن در ده‌دهی است.
کدهای $84\bar{2}\bar{1}$, $2421$ و Excess-3 خود مکمل هستند.

*** گری ({{{lr(Gray)}}})
کد خاکستری، Gray یا انعکاسی کدی است که در آن هر عدد با عدد بعدی فقط در یک رقم تفاوت دارد.

برای تبدیل دودویی به گری می‌توان عدد سمت چپ را نوشت و سپس عدد سمت راست را با آن =xor= (بررسی تفاوت) می‌کنیم و حاصل را جای عدد سمت راست می‌نویسیم.

#+CAPTION: مثال کد دودویی به گری
| Binary | Gray |
|--------+------|
|  <c>   | <c>  |
|  0000  | 0000 |
|  0001  | 0001 |
|  0010  | 0011 |
|  0011  | 0010 |
|  0100  | 0110 |
|  0101  | 0111 |
|  0110  | 0101 |
|  0111  | 0100 |
|  1000  | 1100 |
|  1001  | 1101 |
| ...    |      |

#+CAPTION: کد گری حلزونی که در جدول کارنو حالتی پیچشی دارد.
| Binary | Gray |
|--------+------|
|  <c>   | <c>  |
|  0000  | 0101 |
|  0001  | 0111 |
|  0010  | 1111 |
|  0011  | 1101 |
|  0100  | 1100 |
|  0101  | 0100 |
|  0110  | 0000 |
|  0111  | 0001 |
|  1000  | 0011 |
|  1001  | 0010 |
|  1010  | 0110 |
|  1011  | 1110 |
|  1100  | 1010 |
|  1101  | 1011 |
|  1110  | 1001 |
|  1111  | 1000 |

*** اسکی
اسکی به حالت استاندارد ۷ بیت است. به طور افزوده ۸ بیت که شامل علائم خاص خط‌الرسم لاتین نیز می‌باشد.
سه بیت به عنوان ستون و چهار بیت به عنوان سطرهای یک جدول خوانده می‌شوند.

#+CAPTION: جدول اسکی
#+ATTR_LATEX: :font \footnotesize
|       |            000            |                001                 |    010     | 011 | 100 | 101 | 110 | 111      |
|-------+---------------------------+------------------------------------+------------+-----+-----+-----+-----+----------|
|   /   |             <             |                                    |            |     |     |     |     |          |
|  <c>  |            <c>            |                <c>                 |    <c>     | <c> | <c> | <c> | <c> |          |
| 00000 |        NUL (Null)         |       DLE (Data Line Escape)       | SP (Space) |  0  |  @  |  P  |  `  | p        |
| 00001 |  SOH (Start of Heading)   | DC1 (Device Control 1 (oft. XON))  |     !      |  1  |  A  |  Q  |  a  | q        |
| 00010 |    STX (Start of Text)    |       DC2 (Device Control 2)       |     "      |  2  |  B  |  R  |  b  | r        |
| 00011 |     ETX (End of Text)     | DC3 (Device Control 3 (oft. XOFF)) |     #      |  3  |  C  |  S  |  c  | s        |
| 00100 | EOT (End of Transmission) |       DC4 (Device Control 4)       |     $      |  4  |  D  |  T  |  d  | t        |
| 00101 |       ENQ (Enquiry)       |   NAK (Negative Acknowledgement)   |     %      |  5  |  E  |  U  |  e  | u        |
| 00110 |   ACK (Acknowledgment)    |       SYN (Synchronous Idle)       |     &      |  6  |  F  |  V  |  f  | v        |
| 00111 |        BEL (Bell)         |    ETB (End of Transmit Block)     |     '      |  7  |  G  |  W  |  g  | w        |
| 01000 |      BS (Back Space)      |            CAN (Cancel)            |     (      |  8  |  H  |  X  |  h  | x        |
| 01001 |    HT (Horizontal Tab)    |         EM (End of Medium)         |     )      |  9  |  I  |  Y  |  i  | y        |
| 01010 |      LF (Line Feed)       |          SUB (Substitute)          |     *      |  :  |  J  |  Z  |  j  | z        |
| 01011 |     VT (Vertical Tab)     |            ESC (Escape)            |     +      |  ;  |  K  |  [  |  k  | {        |
| 01100 |      FF (Form Feed)       |        FS (File Separator)         |     ,      |  <  |  L  |  \  |  l  | \vert        |
| 01101 |   CR (Carriage Return)    |        GS (Group Separator)        |     -      |  =  |  M  |  ]  |  m  | }        |
| 01110 |   SO (Shift Out / X-On)   |       RS (Record Separator)        |     .      |  >  |  N  |  ^  |  n  | ~        |
| 01111 |   SI (Shift In / X-Off)   |        US (Unit Separator)         |     /      |  ?  |  O  |  _  |  o  | (Delete) |

** توازن ({{{lr(Parity)}}})
بیت‌های توازن بیت‌هایی مازاد بر داده هستند که به عیب‌یابی و در مواردی حل آن کمک می‌کنند.

به طور کل برای ایجاد توازن بیت‌های یک را می‌شمارند.
اگر هدف در ایجاد توازن فرد است، سعی می‌کنیم تعداد بیت‌های یک را فرد کنیم (بیت توازن، هنگام زوجی بیت‌های یک داده، یک می‌شود).
اگر هدف در ایجاد توازن زوج است، سعی می‌کنیم تعداد زوج‌های یک را فرد کنیم (بیت توازن، هنگام زوجی بیت‌های یک داده، یک می‌شود).

هنگامی که بیت سمت چپ یک است توازن زوج بهتر جواب می‌دهد.*
# TODO Check the claim

*** همپوشان ({{{lr(Overlapping)}}})
توازن برای بلوکی از داده‌ها را توازن همپوشان ({{{lr(Overlapping)}}}) می‌خوانند.
به این صورت است که توازن را از ستون‌ها و سطرهای بلاک می‌گیریم.

#+CAPTION: مثال توازن همپوشان زوج
| / |   |   | > |   |
| 1 | 0 | 1 | 1 | 1 |
| 0 | 0 | 1 | 0 | 1 |
| 1 | 0 | 1 | 0 | 0 |
|---+---+---+---+---|
| 0 | 0 | 1 | 1 | 0 |

توازن همپوشان قابلیت پیدا کردن بیت خطادار را به ما می‌دهد.

#+CAPTION: مشخص بودن مکان بیت خطادار
| / |     |   | > |     |
| 1 |   0 | 1 | 1 |   1 |
| 0 | +1+ | 1 | 0 | *1* |
| 1 |   0 | 1 | 0 |   0 |
|---+-----+---+---+-----|
| 0 | *0* | 1 | 1 |   0 |

*** سرجمع ({{{lr(Checksum)}}})
سرجمع به طور کل با جمع تمام بیت‌ها صحت داده را بررسی می‌کند.

در سرجمع‌ها داده‌ها را با یکدیگر جمع کرده و در صورت وجود کری:
- در Single-precision آنرا دور می‌اندازیم.
- در Double-precision آنرا ذخیره کرده و تا نزدیکترین $2^n$ صفر به آن اضافه می‌کند.
- در Residue آنرا با سرجمع دوباره جمع می‌کنیم.

در سرجمع Honeywell با سطرهای زوج و فرد دو بلاک درست کرده و آنها را به یکدیگر پیوند می‌دهیم و از آن جمع می‌گیریم.

#+CAPTION: سرجمع‌ها
|   0000 |     0000 |    0000 |           |
|   0101 |     0101 |    0101 |           |
|   1111 |     1111 |    1111 |  00000101 |
|   0010 |     0010 |    0010 |  11110010 |
|--------+----------+---------+-----------|
|   0110 | 00010110 |    0111 | 11110111  |
| Single |   Double | Residue | Honeywell |

*** همینگ ({{{lr(Hamming)}}})
کد همینگ کدی برای تشخیص و تصحیح است.

فاصله همینگ تفاوت بین بیت‌های دو عدد $a$ و $b$ است ($d(a,b)$)
به طور مثال:

\begin{align*}
d(&111001,\\
  &010110)=5
\end{align*}
\begin{align*}
d(&000000,\\
  &111000)=3
\end{align*}

همینگ برای کدی که فاصلهٔ $d$ دارد می‌تواند:
- $d-1$ خطا را تشخیص دهد.
- $\lfloor\frac{d-1}{2}\rfloor$ خطا را تصحیح کند.

بیت‌های توازن کد همینگ در جایگاه‌های توان دوی داده ($1,2,4,8\ldots$) قرار می‌گیرند.

برای هر عدد $n$ رقمی $r$ بیت توازن لازم است که از $2^r-1>=n+r$ به دست می‌آید.

به طور کل هر بیت توازن تمام بیت‌های پیش‌روی خودی را شامل می‌شود که $and$ بیتی موقعیت بیت توازن با موقعیت آن بیت صفر نباشد.

بنابراین اگر رشتهٔ زیر را داشته باشیم که از تعدادی بیت توازن $p$ و داده $d$ تشکیل شده است:

#+CAPTION: عدد $0101$ بدون توازن
\begin{equation*}
\overset{p_1}{[]}\overset{p_2}{[]}\overset{d_3}{0}\overset{p_4}{[]}\overset{d_5}{1}\overset{d_6}{0}\overset{d_7}{1}
\end{equation*}

- بیت $p_1$ حاوی وضعیت توازن تمام بیت‌هایی است که $\wedge$ موقعیت آنها با $1$ ناصفر است ($1,3,5,7,9,\ldots$).
- بیت $p_2$ حاوی وضعیت توازن تمام بیت‌هایی است که $\wedge$ موقعیت آنها با $2$ ناصفر است ($2,3,6,7,10,11,\ldots$).
- بیت $p_4$ حاوی وضعیت توازن تمام بیت‌هایی است که $\wedge$ موقعیت آنها با $4$ ناصفر است ($[4-7],[12-15],[20-23],\ldots$).
- بیت $p_8$ حاوی وضعیت توازن تمام بیت‌هایی است که $\wedge$ موقعیت آنها با $8$ ناصفر است ($[8-15],[24-31],[40-47],\ldots$).

وضعیت توازن با $\oplus$ بیت‌های تحت دامنهٔ هر بیت توازن است. بنابرین برای عدد بالا $0101$ بیت‌های پریتی اینگونه پر خواهند شد:

#+CAPTION: بیت‌های توازن عددی ۴ رقمی
\begin{equation}\begin{split}
p_1 &= d_3 \oplus d_5 \oplus d_7\\
p_2 &= d_3 \oplus d_6 \oplus d_7\\
p_4 &= d_5 \oplus d_6 \oplus d_7
\end{split}\end{equation}

در نتیجه عدد با توازن برابر $0110101$ خواهد بود.

#+CAPTION: عدد $0101$ با بیت‌های توازن
\begin{equation*}
\overset{p_1}{0}\overset{p_2}{1}\overset{d_3}{1}\overset{p_4}{0}\overset{d_5}{1}\overset{d_6}{0}\overset{d_7}{1}
\end{equation*}
  
گیرنده با $\oplus$ کردن خود بیت توازن با داده‌های تحت دامنه می‌تواند به خطا یا بی‌خطا بودن پی ببرد.

#+CAPTION: نحوه به دستیابی خطای کد همینگوی
\begin{equation}\begin{split}
c_1 = p_1 \oplus d_3 \oplus d_5 \oplus d_7\\
c_2 = p_2 \oplus d_3 \oplus d_6 \oplus d_7\\
c_3 = p_4 \oplus d_5 \oplus d_6 \oplus d_7
\end{split}\end{equation}

با زنجیری نوشتن $c_1$ تا $c_n$ عددی به دست می‌آید که مکان خطا را نشان می‌دهد.
صفر یعنی خطایی وجود ندارد.

* جبر بول، ساده‌ساز، EPI و PI

#+begin_src latex :file .medar-beginner_gates.png
\begin{circuitikz}[every node/.style={fill=white, node distance=1.5cm}] \draw
(0,0) node[and port]{$\cdot$}
(2,0) node[or port]{$+$}
(4,0) node[xor port]{$\oplus$}
(0,-2) node[nand port]{$\uparrow$}
(2,-2) node[nor port]{$\downarrow$}
(4,-2) node[xnor port]{$\bigodot$}
(5.3,-2) node[not port](not){} (not) node[left]{\small$\neg$}
;\end{circuitikz}
#+END_SRC

#+CAPTION: گیت‌های عملگرهای رایج منطقی
#+RESULTS:
[[file:.medar-beginner_gates.png]]

نقطه سفید پایپ را $\neg$ می‌کند.

یک {{{lr(Product term)}}} رویه‌ای از ضرب ($\wedge$) چندین عبارت و $\neg$ است.
یک {{{lr(Sum term)}}} رویه‌ای از حاصل جمع ($\vee$) چندین عبارت و $\neg$ است.
یک تک عبارت به تنهایی هم Product و هم {{{lr(Sum term)}}} است.

دوگانی ({{{lr(Duality)}}}) با تعویض $\wedge$​ها با $\vee$​ها و $\neg$ کردن صفرها و یک‌های ثابت هر عبارت معادل آن به دست می‌آید که به آن دوگان می‌گویند.

یک {{{lr(Min-term)}}} نوعی عبارت ضربی است که هر ورودی تابع آن دقیقاً یک بار در آن تکرار می‌شود. مین‌ترم با $m$ نشان داده می‌شود و فقط یک حالت یک می‌شود.
یک {{{lr(Max-term)}}} نوعی عبارت جمعی است که هر ورودی تابع آن دقیقاً یک بار در آن تکرار می‌شود. ماکس‌ترم با $M$ نشان داده می‌شود و فقط یک حالت صفر می‌شود.

#+NAME: tb:mins
#+CAPTION: مین‌ترم‌های سه ورودی
|     |     |     |           $m0$            |         $m1$          |         $m2$         |    $m3$     |       $m4$        |    $m5$     |    $m6$     | $m7$  |
| $x$ | $y$ | $z$ | $\bar{x}\wedge\bar{y}\wedge\bar{z}$ | $\bar{x}\wedge\bar{y}\wedge{}z$ | $\bar{x}\wedge{}y\wedge{}\bar{z}$ | $\bar{x}\wedge{}y\wedge{}z$ | $x\wedge{}\bar{y}\wedge{}\bar{z}$ | $x\wedge{}\bar{y}\wedge{}z$ | $x\wedge{}y\wedge{}\bar{z}$ | $x\wedge{}y\wedge{}z$ |
|-----+-----+-----+---------------------------+-----------------------+----------------------+-------------+-------------------+-------------+-------------+-------|
|  /  |     |  >  |                           |                       |                      |             |                   |             |             |       |
| <c> | <c> | <c> |            <c>            |          <c>          |         <c>          |     <c>     |        <c>        |     <c>     |     <c>     |  <c>  |
|  0  |  0  |  0  |             1             |           0           |          0           |      0      |         0         |      0      |      0      |   0   |
|  0  |  0  |  1  |             0             |           1           |          0           |      0      |         0         |      0      |      0      |   0   |
|  0  |  1  |  0  |             0             |           0           |          1           |      0      |         0         |      0      |      0      |   0   |
|  0  |  1  |  1  |             0             |           0           |          0           |      1      |         0         |      0      |      0      |   0   |
|  1  |  0  |  0  |             0             |           0           |          0           |      0      |         1         |      0      |      0      |   0   |
|  1  |  0  |  1  |             0             |           0           |          0           |      0      |         0         |      1      |      0      |   0   |
|  1  |  1  |  0  |             0             |           0           |          0           |      0      |         0         |      0      |      1      |   0   |
|  1  |  1  |  1  |             0             |           0           |          0           |      0      |         0         |      0      |      0      |   1   |

#+NAME: tb:maxes
#+CAPTION: ماکس‌ترم‌های سه ورودی
|     |     |     |  $M0$   |     $M1$      |     $M2$      |        $M3$         |     $M4$      |        $M5$         |        $M6$         |           $M7$            |
| $x$ | $y$ | $z$ | $x\vee{}y\vee{}z$ | $x\vee{}y\vee{}\bar{z}$ | $x\vee{}\bar{y}\vee{}z$ | $x\vee{}\bar{y}\vee{}\bar{z}$ | $\bar{x}\vee{}y\vee{}z$ | $\bar{x}\vee{}y\vee{}\bar{z}$ | $\bar{x}\vee{}\bar{y}\vee{}z$ | $\bar{x}\vee{}\bar{y}\vee{}\bar{z}$ |
|-----+-----+-----+---------+---------------+---------------+---------------------+---------------+---------------------+---------------------+---------------------------|
|  /  |     |  >  |         |               |               |                     |               |                     |                     |                           |
| <c> | <c> | <c> |   <c>   |      <c>      |      <c>      |         <c>         |      <c>      |         <c>         |         <c>         |            <c>            |
|  0  |  0  |  0  |    0    |       1       |       1       |          1          |       1       |          1          |          1          |             1             |
|  0  |  0  |  1  |    1    |       0       |       1       |          1          |       1       |          1          |          1          |             1             |
|  0  |  1  |  0  |    1    |       1       |       0       |          1          |       1       |          1          |          1          |             1             |
|  0  |  1  |  1  |    1    |       1       |       1       |          0          |       1       |          1          |          1          |             1             |
|  1  |  0  |  0  |    1    |       1       |       1       |          1          |       0       |          1          |          1          |             1             |
|  1  |  0  |  1  |    1    |       1       |       1       |          1          |       1       |          0          |          1          |             1             |
|  1  |  1  |  0  |    1    |       1       |       1       |          1          |       1       |          1          |          0          |             1             |
|  1  |  1  |  1  |    1    |       1       |       1       |          1          |       1       |          1          |          1          |             0             |

#+begin_src latex :file .medar-m3_mingate.png
\begin{circuitikz}[every node/.style={fill=white}] \draw
node[and port,number inputs=3](and){$m3$}
(and.in 1) node[left]{\tiny$x$}
(and.in 2) node[left]{\tiny$y$}
(and.in 3) node[left]{\tiny$z$}
(and.bin 1) node[ocirc,left]{}
;\end{circuitikz}
#+END_SRC

#+ATTR_LATEX: :width .2\textwidth
#+CAPTION: مین‌ترم $\bar{x}yz$ که فقط عدد سه دودویی آنرا یک می‌کند.
#+RESULTS:
[[file:.medar-m3_mingate.png]]

#+begin_src latex :file .medar-M3_maxgate.png
\begin{circuitikz}[every node/.style={fill=white}] \draw
node[or port,number inputs=3](or){$M3$}
(or.in 1) node[left]{\tiny$x$}
(or.in 2) node[left]{\tiny$y$}
(or.in 3) node[left]{\tiny$z$}
(or.bin 2) node[ocirc,left]{}
(or.bin 3) node[ocirc,left]{}
;\end{circuitikz}
#+END_SRC

#+ATTR_LATEX: :width .2\textwidth
#+CAPTION: ماکس‌ترم $x+\bar{y}+\bar{z}$ که فقط عدد سه دودویی آنرا صفر می‌کند.
#+RESULTS:
[[file:.medar-M3_maxgate.png]]

به عبارات ضربی که بین آنها جمع اتفاق بیوفتد {{{lr(SOP)}}} یا {{{lr(Sum of Products)}}} می‌گویند.
به عبارات جمعی که بین آنها ضرب اتفاق بیوفتد {{{lr(POS)}}} یا {{{lr(Product of Sums)}}} می‌گویند.

به طور خلاصه می‌توان SOP (جمع مین‌ترم‌ها) را به صورت $\sum_{xyz}(a,b,c,\ldots)$ می‌نویسند که در آن $a$, $b$, $c$ شماره مین‌ترم‌های مورد نظر است.
بنابراین $(\bar{x}\bar{y}z)+(\bar{x}y\bar{z})+(\bar{x}yz)+(x\bar{y}\bar{z})$ را که بر اساس جدول ref:tb:mins معادل $m1+m2+m3+m4$ است را به صورت $\sum_{xyz}(1,2,3,4)$ نگاشت.

مشابه SOP می‌توان جمع ماکس‌ترم‌ها یا POS را به صورت $\prod_{xyz}(a,b,c,\ldots{})$ نوشت که در آن $a$, $b$, $c$ شماره ماکس‌ترم‌های مورد نظر است.
بنابراین $(x+\bar{y}+\bar{z})(\bar{x}+y+z)(\bar{x}+y+\bar{z})$ را که بر اساس جدول ref:tb:maxes معادل $M3+M4+M5$ است را به صورت $\prod_{xyz}(3,4,5)$ نگاشت.

# * گیت‌ها، منطق سه حالته، هازاد و تکنولوژی‌های ساخت تراشه
# * مدارات ترکیبی
# * لچ و فلیپ فلاپ
# * تحلیل مدارات ترتیبی سنکرون، میلی و مور و شمارنده و ثبات
# * طراحی مدارات ترتیبی سنکرون و کاهش حالت
# * سنتز مدار
