#+TITLE: پیش‌نویس جزئیات پروژهٔ درس مباحث ویژه -- راه‌اندازی خانه هوشمند
#+AUTHOR: محمدیاسین داوده و مهدی صفریان

#+LATEX_HEADER: \usepackage{tcolorbox}
#+LATEX_HEADER: \newenvironment{alertblock}[1][]{\begin{tcolorbox}[#1,colback=red!5,colframe=red!70!black]}{\end{tcolorbox}}
#+LATEX_HEADER: \newenvironment{infoblock}[1][]{\begin{tcolorbox}[#1,colback=cyan!5,colframe=blue!70!black]}{\end{tcolorbox}}
#+LATEX_HEADER: \newenvironment{warnblock}[1][]{\begin{tcolorbox}[#1,colback=yellow!5,colframe=yellow!70!black]}{\end{tcolorbox}}
#+LATEX_HEADER: \def\UrlBreaks{\do\/\do-}
#+LATEX_HEADER: \usepackage{facro,fullpage}
#+LATEX_HEADER: \usepackage{titlingpage1} \project{گزارشات مرتبط با درس مباحث ویژه} \supervisor{ساسان برهلیا}

# * مقدمه
* پیش نیازها
برای هر پروژهٔ IoT که در آن وضعیت سنسورها نیاز به تحلیل یا منطق داشته باشد نیاز به پردازنده‌ای قابل برنامه‌نویسی وجود دارد.
برای پشتیبانی از چنین سنسورهایی این پردازنده‌ها باید مجهز به پین‌‌های ورودی و خروجی عمومی یا GPIO{{{lfn(General Input Output Pins)}}} باشند تا بتوانند سیگنال‌های سنسورها را دریافت، اکتویتورها
را فعال و انرژی قطعات را تأمین کنند.

میکروکنترل‌ها پردازنده‌های کوچکی هستند که برای چنین پروژه‌هایی ساخته شده‌اند.
از این جهت می‌توان از چنین میکروکنترل‌هایی مانند آردوینو برای این پروژه استفاده کرد.
ما در این پروژه از برد {{{lr(Raspberry Pi 3B)}}} استفاده می‌کنیم که یک برد با پردازنده آرم و GPIO است.
برای اتصال سنسورها به GPIO احتیاج است.

سنسورها معمولاً ورودی‌های $3.3V$ و $5.0V$ استفاده می‌کنند.
در نتیجه مهم است که GPIO بتواند $5.0V$ را پشتیبانی کند در غیر این نیاز به یک PSU{{{lfn(Power Supply Unit)}}} جداگانه وجود دارد.

برای این پروژه ما سه ماژول گلدان هوشمند، تشخیص گاز و الکل‌ریز هوشمند نیازمند سنسورهای متفاوتی هستیم.
برای راحتی کار از ماژول‌های این سنسورها استفاده می‌کنیم که آماده به کار هستند روی یک برد هستند.
یک سنسور رطوبت خاک{{{lfn(YL-69)}}}, سنسور مجاورت مادون قرمز{{{lfn(IRFC51)}}} و سنسور گاز{{{lfn(MQ-5)}}} مورد استفاده است.

برای انجام فعالیت‌ها به دو عدد رله، یک موتور چرخشی و یک پمپ آب نیاز است.

به طور کل لیست وسایل مورد استفاده در این پروژه به شرح زیر است:
- سنسورها
  + ماژول رطوبت خاک
  + ماژول مجاورت مادون قرمز
  + ماژول تشخیص گاز
- عملگرها
  + موتور چرخش
  + پمپ آب
- سایر
  + {{{lr(Raspberry Pi 3B)}}}
  + سیم
  + رله (دوعدد یا یک رله دو کاناله)
  + بردبرد ({{{lr(Breadboard)}}}) (اختیاری)
  + PSU بردبرد (اختیاری)
  + سیستمی ثانوی (اختیاری در صورت استفاده از {{{lr(Raspberry)}}})

در این برگه فرض بر این است که کاربر از برد پای، یک سیستم ثانوی و سیستم‌عامل‌های Raspbian/RasberryOS و لینوکسی دیگر استفاده می‌کنند که همه بر پایه SystemD است.

* راه‌اندازی اولیه برد پای
پیش از استفاده از برد پای روی آن سیستم‌عامل لینوکس را ریخته و نصب می‌کنیم.
پس از این، برای برنامه‌نویسی در پایتون نیاز به کتابخانهٔ [[https://pypi.org/project/RPi.GPIO/][RPi.GPIO]] برای مدیریت GPIO داریم که به طور پیش‌فرض روی توزیع {{{lr(Raspberry Pi OS)}}} و {{{lr(Raspbian)}}} موجود است.

برای کار با برد پای از طریق سیستمی ثانوی می‌توان با SSH یا کابل TTL که به پین‌های {{{lr(GND)}}}, 8 (کابل سفید) و 10 (کابل سبز) ارتباط برقرار می‌کند متصل شد.
پیش از برقراری این ارتباطاتات باید با {{{sh(raspberry-config)}}} قابلیت SSH یا/و سریال را فعال کرد (بیشتر در [[مختصری بر SSH]]).

# TODO rpi config stuff about TTL/serial come here


پس از این با ادیتور مورد علاقه با پشتیبانی از SSH (مثلاً {{{lr(Emacs Tramp)}}}) یا ابزاری مناسب کار با TTL مانند {{{lr(tio)}}} به شکل {{{sh(tio /dev/ttyUSB)}}} به کدزدن پرداخت.

#+NAME: fg:gpio
#+CAPTION: پین‌های GPIO برد پای
file:images/piot-pins.jpg

** مختصری بر SSH
برای ارتباط آسان و ویرایش فایل‌ها با دستگاهی ثانوی --به جز برد پای-- نیازمند ارتباطی هستیم.
یکی از بهترین پروتکل‌های ارتباطی برای این کار SSH است که به کاربر یک شل کامل نه تنها فقط برای ارسال اطلاعات متنی --به عکس {{{lr(TTL)}}}-- بلکه می‌توان فایل و سایر داده‌های پیچیده‌تر را روی آن انتقال داد.
#+BEGIN_alertblock
در صورت غفلت در تنظیم صحیح، SSH می‌تواند پروتکلی خطرناک باشد.
امنیت SSH را تأمین کنید. ارتباطات را به شبکه محلی محدود کنید و حتی المکان پس از انجام این پروژه قابلیت‌های SSH را غیرفعال کنید.
#+END_alertblock

# TODO نحوه لوکال کردن

برای راه‌اندازی یک سرور ساده SSH کافی است که دیمن آنرا روی سرور نصب کرده و آنرا اجرا کنید.
برای این کار ابتدا با کابل TTL با سرور ارتباط برقرار می‌کنیم.
روی آن OpenSSH را نصب کرده (از پیش با Raspbian/RaspberryOS همراه است) و آنرا اجرا می‌کنیم (برای سیستم‌دی: {{{sh(systemctl enable sshd)}}} و {{{sh(systemctl start sshd)}}}).

# TODO rpi config stuff about SSH come here

پس از راه‌اندازی و بررسی SSH می‌توان به آن متصل شد.
برای اتصال راحت‌تر بهتر است به سرور خود آی‌پی استاتیک از DHCP داده یا از سمت خود سرور درخواست آی‌پی ترجیحی کنید.
اگر سرور با موفقیت راه‌اندازی شده باشد می‌توانید با {{{sh(ssh $username@$ip -p $port)}}} به آن متصل شد.[fn::=$= علامت متغییر در شل است. به طور مثال جای {{{sh($ip)}}} آی‌پی‌آدرس خود را بنویسید یا با {{{sh(ip="192.168.1.111")}}} آنرا تنظیم کنید.]
پورت پیش‌فرض SSH پورت 22 است.
پس از این باید با پرامپت رمز خود مواجه شوید.

برای اتصال ساده‌تر و امکان مدیریت راحت می‌توانید به فایل کانفیگ خود (پیش‌فرض =~/.ssh/config=) خطوط زیر را به این صورت اضافه کنید ({{{sh($alias)}}} نام مستعار سرور باشد):

#+begin_src sh :exports code
cat >>~/.ssh/config <<EOF
Host $alias
    HostName $ip
    User $user
    Port $port
EOF
#+end_src

پس از این می‌توانید با {{{sh(ssh $alias)}}} به سرور خود متصل شوید.

- اگر این نام مستعار را در کانفیگ فایل خود وارد نکرده‌اید از اینجا به بعد به جای {{{sh($alias)}}} از همان قالب =username@ip:port= استفاده کنید.

در نهایت برای گذر از مشکل درخواست رمز می‌توانید از کلید هویت استفاده کنید.
برای این کاری کافیست با {{{sh(ssh-keygen -t rsa)}}} یک جفت کلید عمومی با نام دلخواه بسازید و با {{{sh(ssh-copy-ip $alias)}}} کلید عمومی خود را به لیست کلیدهای مجاز (پیش‌فرض =~/.ssh/authorized_keys=) بیافزایید.

پس از این اگر {{{sh(eval $(ssh-agent))}}} کرده و کلید خصوصی را به هویت خود با {{{sh(ssh-add ~/.ssh/key)}}} بیافزاید، سرور از شما رمز عبوری نمی‌خواهد.

برای اضافه کردن کلید به طور اتوماتیک می‌توانید از پارامتر =IdentityFile= در فایل کانفیگ استفاده کنید.
به این صورت کانفیگ نهایی شما شبیه فایل زیر خواهد بود:

#+CAPTION: کانفیگ نمونه نام مستعار در سیستم ثانوی
#+begin_src text
Host rpi
    HostName 192.168.1.111
    User pi
    IdentityFile ~/.ssh/id_rpi
#+end_src

** راه‌اندازی Tor
برای ارتباط باثبات‌تر یا از روترهایی که دسترسی به شبکه تلگرام ندارند می‌توانید به سادگی تور را نصب کرده ({{{sh(apt install tor)}}}) و مشابه SSH سرویس آنرا اجرا ({{{sh(systemctl start tor)}}}) و فعال ({{{sh(systemctl enable tor)}}}) کنید.
در صورتی که با خطا مواجه شد باید آنرا (یا پلی برای ارتباط) تنظیم کنید.
اگر تور فعال باشد به طور پیش‌فرض روتر/پروکسی روی پورت 9050 (مرورگر تور 9150) خواهید داشت که به اتصال ما کمک می‌کند.
#+BEGIN_alertblock
ممکن است استفاده از تور یا پروکسی توسط مدیر شبکه، ISP یا دولت قانونی طلقی نشود.
پیش از راه‌اندازی بررسی کنید.
#+END_alertblock

* کار با ماژول‌ها
** اصطلاحات
ماژول‌های پین‌هایی دارند که با عنوانی مانند =VCC=, =AO= و... نشانه‌گذاری شده‌اند.
پین =VCC= پین برق است. ابتدا باید مشخص کرد که برق مورد نیاز هر ماژول $3.3V$ یا $5.0V$ است.
ولتاژ کم رساندن به ماژول خطرساز نیست از بیش از ولتاژ مورد قبول به آن تحمیل کردن ممکن است باعث خرابی شود.
ماژول‌هایی که اینجا استفاده می‌کنیم همه از $5.0V$ استفاده می‌کنند.

پین =GND= پین منفی، پین =DO= پین خروجی دیجیتالی (دودویی) است و در نهایت پین =AO= پین
خروجی آنالوگ است.

معمولاً مقاومتی به نام پتانسیومتر (شکل ref:fg:potentiometer) روی این ماژول‌ها وجود دارد که آستانهٔ یک (یا صفر) شدن =DO= را مشخص می‌کند.

#+name: fg:potentiometer
#+CAPTION: پتانسیومترهای مختلف
file:images/piot-potentiometer.png

** برقراری اتصال
برای کار با هر ماژولی باید برق آنرا تأمین کرده و سپس پین =DO= آنرا به یک GPIO (زرد روی ref:fg:gpio) وصل می‌کنیم.
بعداً برای دسترسی به آن می‌توان از طریق شماره‌های فیزیکی پایه (1-40) یا شماره GPIO به آن دسترسی پیدا کرد.
در نهایت GND را متصل می‌کنیم.
#+BEGIN_alertblock
*هرگز* رلهٔ یک کاناله را به $5.0V$ متصل نکنید.
#+END_alertblock

** برنامه‌نویسی
پس از اتصال ماژول‌ها به برد می‌توان آنها را برنامه‌نویسی کرد.

یکی از آسان‌ترین زبان‌ها برای شروع Hy یا Python می‌باشد.
در این پروژه از های استفاده می‌کنیم که لیسپی از پایتون است.
اگر لیسپ، پایتون یا های را بلدید می‌توانید هر کدام از دیگر سه را در چند ساعت بیاموزید.
بعلاوه کدهای پایتون و های با =hy2py= و =py2hy= به یکدیگر تبدیل می‌شوند.
برای جزئیات بیشتر درباره های به سایت آن https://hylang.org و مستندات آن[fn::https://docs.hylang.org/en/stable/language/api.html] مراجعه کنید.

علاوه بر این نیازمند درک پایه‌ای از YAML دارید.

** معرفی فایل‌ها
    - *settings-example.yaml*
      همانطور که از نام آن مشخص است این فایل صرفا یک مثال است و باید یک فایل با نام =settigns.yaml= بسازید و اطلاعات درون مثال را به فایل جدید منتقل کنید و با توجه به شرایط خودتان آن را تکمیل کنید.

      تمامی تنظیمات مربوط به پروژه اعم از افرادی که می‌توانند به بات تلگرامی دستور دهند، توکن(=token=) بات، حسگرها و ماژول‌هایی که قرار است به برد متصل شوند و دستوراتی که بات باید نسبت به آن‌ها واکنشی نشان دهد در این فایل نگه‌داری می‌شوند. (برای اطلاعات درباره نحوه تکمیل فایل تنظیمات مراجعه شود به بخش [[sec:settings]])
    - *settings.hy*

      عناصر و تنظیماتی که در فایل =settings.yaml= نوشته می‌شوند توسط این اسکریپت فراخوانی می‌شوند. اگر تنظیمات جدیدی اعمال شود این اسکریپت به راحتی تغییرات جدید را به برنامه می‌دهد و از آن به بعد بات تلگرامی با تنظیمات اعمال‌ شده جدید کار می‌کند. هدف از ساخت این فایل ایجاد متغییر‌هایی پویا است که بتوان از طریق دیگر اسکریپت‌های =hy= از این متغییرها استفاده کرد و از فراخوانی تنظیمات در هر اسکریپت به صورت جداگانه جلوگیری شود.
    - *board.hy*

      کنترل رله، دریافت و اجرای دستورات از طریق بات تلگرامی و تعیین زمان‌بندی سیستمی یا همان کرون جاب توسط این اسکریپت مدیریت می‌شوند که زیر یک کلاس به نام =Module= قرار دارند.
      کلاسی دیگری به نام =GPIO= وجود دارد که مدیریت ماژول‌های متصل به برد که در فایل تنظیمات اضافه شده‌اند را بر‌عهده دارد و آن را به لیست ماژول‌های موجود اضافه می‌کند.
    - *bot.hy*

        تمامی توابع عملگر بات تلگرامی در این اسکریپت وجود دارد.

        ابتدا با یک کلاس به نام brain مواجه هستیم. توابع که در این کلاس استفاده شدن صرفا برای تعامل ربات با کاربر در تلگرام است تا بتواند لیست ماژول‌های موجود یا وضعیت آن را نمایش دهد.
*** settings.yaml
**** دسترسی‌ها
<<sec:settings>>

    برای تعیین دسترسی افرادی که می‌توانند به بات تلگرام فرمانی دهند باید نام کاربری تلگرام افراد را در بخش =admins= تعریف کنید.

    #+BEGIN_SRC yaml :exports code
    admins:
    - "@person1"
    - "@person2"
    - "@person3"
    #+END_SRC

**** اتصال بات تلگرام

برای اتصال برنامه به یک بات تلگرامی ابتدا باید با استفاده از =@botfather= یک بات تلگرامی بسازید و سپس آدرس توکن(=token=) بات را در قسمت =token= بنویسید.

#+BEGIN_SRC yaml :exports code
token: 1234567890123456789012345678901234567890
#+END_SRC

**** مشخص کردن نوع برد

نوع برد‌ها یا =BOARD= هستند یا =BCM= که استاندارد خواندن پین‌های موجود بر روی برد‌ها است. در شکل ref:fg:gpio

#+BEGIN_SRC yaml
gpio: BOARD # or BCM
#+END_SRC

**** انتخاب زبان بات

    متغییر =locale= زبان بات را مشخص می‌کند که مثلا به چه زبانی پاسخ شما را بدهد.

    پیش فرض فایل تنظیمات فارسی(=fa-IR=) است.

#+BEGIN_SRC yaml
locale: "fa-IR" # or "en-GB"
#+END_SRC

**** کلید پروکسی

برای راه اندازی پروکسی که قبلا گفته شده بود به شکل زیر از آن استفاده می‌کنیم.

#+begin_infoblock
یادآوری: تنها از پروکسی نوع socks5 پشتیبانی می‌شود.
#+end_infoblock

#+BEGIN_SRC yaml
proxy: socks5://[ip]:[port]
#+END_SRC

**** تعریف سنسورها

برای تعریف سنسور‌ها باید در بخش =modules= به ازا هر پینی که فعال است حسگر خود را تعریف کنیم.
مدیریت سنسور‌های می‌تواند به صورت دستی یا حتی خودکار باشد. برای تعریف حالت خودکار سنسور‌ها در بخش [[sec:auto]] درباره‌ آن توضیح خواهیم داد.
در حالت دستی شما قادر هستید در هر لحظه به بات فرمان دهید که چه حسگری را فعال یا غیر فعال کند.

برای تعریف یک حسگر به شکل زیر عمل کنید:

#+BEGIN_SRC yaml
modules:
- pin: 11 # pin number
  io: out # $\text{\rl{اگر دستگاهی مانند رله باشد و ورودی بگیرد مقدار in را قرار میدهیم}}$
# $\text{\rl{اگر دستگاه تنها یک حسگر باشد که فقط خروجی تولید می‌کند out را قرار می‌دهیم}}$
  auto: pot # $\text{\rl{ اگر در بخش profiles حالت خودکاری را ثبت کنید نام آن را می‌نویسید.}}$
  profile: man # $\text{\rl{مشخص می‌کند حسگر دستی (man) است یا خودکار (auto)}}$
  aliases: # $\text{\rl{اسامی کلیدی که کمک می‌کند تا بات آن حسگر را بشاند}}$
    en-GB: # $\text{\rl{نکته مهم: اولین نام، نام اصلی است که در کیبورد شیشه‌ای تلگرام نمایش داده ‌می‌شود.}}$
    - pot
    - plant
    - goldan
    # $\text{\rl{همین طور هم برای دیگر زبان‌ها}}$
#+END_SRC


**** حالت خودکار سنسورها
<<sec:auto>>

پروفایل‌ها رفتارهایی هستند که انتظار داریم یک حسگر در حالت خودکار از خود نشان دهد، برای مثال می‌خواهیم حسگر رطوب خاک هر ۵ ساعت چک شود و اگه رطوبت خاک به اندازه کافی نبود رله پمپ آب را روشن کند و گلدان را آبیاری کند.

در بخش پروفایل در حال حاضر مقادیر =duration= که مدت زمان فعال ماندن را مشخص می‌کند، =cron= که الگوی کرون جاب سیستمی را می‌گیرد، =gate= شماره پین گیت است؛
وجود گیت به ما کمک می‌کند تا اگر در کرون لحظه فعال سازی یک راه‌انداز (رله‌) فرا رسیده بود؛ گیت وضعیت حسگر‌ها را بررسی می‌کند که آیا لازم است اجازه فعال‌سازی راه‌انداز داده شود یا نه، =command= شامل دستوراتی است که به بات داده می‌شود و پیامی را بر‌می‌گرداند (فایل =strings.yaml= در پروژه را مطالعه کنید، کلید و دستورات مورد قبول کلاس =brain= در آنجا تعریف شده است).

#+BEGIN_SRC yaml
profiles:
  pot:
    duration: 5 # per second
    cron: '* * * *' # check every minute
    gate: 38 # pin number 38
    command: select %s; on; # read strings.yaml in command section
#+END_SRC


*** اضافه کردن زبان جدید
برای اضافه کردن زبان جدید ابتدا رشته‌های مرتبط با نام هر ماژول را برای صدا کردن آن بروزرسانی کنید. پس از این با بروزرسانی فایل تنظیمات و تغییر =locale= به آن زبان می‌توانید از باتی با آن زبان استفاده کنید.
رشتهٔ خاص =obj_pos= در فایل =strings.yaml= مشخص‌کنندهٔ مکان مفعول هر جمله در هر زبانی است.
به طور مثال وقتی برای فارسی این رشته عدد صفر را دارد یعنی بات باید اولین کلمه هر جمله دستوری را به عنوان شی/ماژولی که باید روی آن دستور را اجرا کنید انتخاب می‌کند.
